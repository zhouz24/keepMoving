创建型模式：包含工厂方法、抽象工厂、单例、原型、建造者。

1、简单工厂、工厂方法、抽象工厂的区别
    以生产车辆为例（比如，长安、传祺）
    简单工厂：属于一个工厂对应多个产品，工厂通过请求的参数判断需要返回哪一个产品的实例，这种方式简单粗暴，但是对于新增一个产品需要修改工厂代码，违反开闭原则
        类似于创建一个车辆接口，写两个类（长安、传祺）实现该接口，在简单工厂类中写一个方法通过输入的参数类型返回对应的车辆（返回参数是接口的实现类），
        假如需要生产一个长安车，通过输入的类型获取对应的长安车，但是每增加一个车辆产品都需要去修改工厂类。
    工厂方法模式：在简单工厂模式的基础上再加上一层封装。只考虑同等级的产品。
        先创建一个车辆接口，一个工厂接口（该接口包含一个返回车辆接口实现类的抽象方法）两个抽象类，
        假如需要创建一个长安车，创建一个车辆品牌（长安）实现车辆接口的时候，同时新增一个（长安）工厂类实现抽象工厂接口，该工厂实现持有抽象方法，返回一个实现车辆接口的长安车实例。
        这种方式实现了开闭原则。每新增一个车的品牌时，同时新增一个类实现抽象车辆接口，和一个实现抽象工厂接口，不需要修改原有的接口。
    抽象工厂模式：工厂方法中每创建一个品牌都需要创建一个工厂，品牌过多时可能导致系统产生类爆炸。抽象工厂在工厂方法的基础上提出一个“产品族”的概念，将相近功能的具体类组成一个族。
        比如生产车辆时，除了车辆品牌，车辆还有不同的颜色，长安车有不同的颜色，传祺车有不同的颜色，这是一个车和颜色的组合。
        新建两个抽象接口（车辆品牌接口、车辆颜色接口）；品牌接口下有两个实现类（长安车、传祺车），颜色接口有两个实现类（黑色、白色）。
        新建一个抽象工厂，该工厂含有两个抽象方法（获取车辆品牌，获取车辆颜色），
        创建两个具体工厂（车辆品牌工厂、车辆颜色工厂）实现抽象工厂，一个工厂获取车辆品牌（车辆品牌接口的实现类）、一个获取车辆颜色（车辆颜色的实现类），进行对应的组合。



2、单例与原型
    单例，在spring中设置scope = singleton，只允许存在一个实例，实现方式有饿汉式（两种），懒汉式（3种），静态内部类，双重校验锁，枚举。
        单例模式于序列化的关系。
            序列化与反序列化通过反射会生成一个全新的对象，破坏单例模式。例如双重校验锁中重写readResolve（）方法，在readResolve中返回实例。
    多例，在spring中设置scope = prototype。多例的实现方式通过重写Object的clone方法（），通过序列化。
        序列化实现多例，通过ByteArrayOutputStream对象bos获取字节数组，ObjectOutputStream对象oos装载字节数组（bos），调用writeObject（this）将字节数组序列化
        ByteArrayInputStream对象（bis）装载字节数组（bos.toCharArray()），在通过ObjectInputStream对象ois装载bis对象，调用readObject()，反序列化生成一个新的对象
        注：反序列化会打破单例模式。
            1、ObjectInputStream的readObject()方法
            2、readObject()方法会调用readObject0(false)方法
            3、readObject0方法中对于Object对象，通过switch判断序列化的是否为TC_OBJECT，是调用checkResolve(readOrdinaryObject(unshared));
            4、readOrdinaryObject方法通过obj = desc.isInstantiable() ? desc.newInstance() : null; 对象是否能在运行时被实例化，能通过反射创建一个新的obj对象
            5、readOrdinaryObject方法会对创建的obj进行判断（obj != null && handles.lookupException(passHandle) == null && desc.hasReadResolveMethod()）
                hasReadResolveMethod（）：如果对象实现了Serializable或者externalizable接口并且重写了readResolve方法返回true
            6、重写了方法会调用Object rep = desc.invokeReadResolve(obj); 通过反射的方式调用要被反序列化的类的readResolve（）方法，
                如果rep不为空，将rep赋值给obj，返回obj。


3、建造者模式：（）
    1、先定义一个产品实体类（pojo）；
    2、创建一个接口，定义实体的属性创建抽象方法，以及一个返回实体的抽象方法
    3、新建一个类实现接口（持有实体对象），实现每个抽象方法，为持有的实体对象设置对应的属性，最后实现返回持有的对象的方法。
    4、创建一个指挥者，建立一个创建方法（传入接口实现对象，返回产品），调用接口实现对象的重写方法，返回接口实现对象的的方法返回产品。
