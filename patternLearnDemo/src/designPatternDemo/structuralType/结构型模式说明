结构型设计模式：
    分为类结构型和对象结构型模式。
    类结构模式关心类的组合，有多个类可以组合成一个更大的系统，在类结构型模式中一般只存在继承关系和实现关系。
    对象结构型模式关心类与对象的组合，通过关联关系是的在一个类中定义另一个类的实例对象，然后通过该对象调用其方法，根据“合成复用原则”，
    在系统中尽量使用关联关系来替代继承关系，因此大部分结构型模式都是对象结构型模式

结构型模式有：适配器、桥接、装饰者、组合、外观、享元、代理

适配器模式：分为类适配器，对象适配器，接口适配器。三个角色：被适配的资源Resource、目标接口Targetee、目标实现类Target、适配器Adaptor
    已电压适配器为例，220V转换成5V的手机充电器
    类适配器：Resource资源是220V的电压输出，Targetee是用户需要的输出接口，Target是具体输出接口，适配器Adaptor继承Resource实现Target，
        Adaptor获取Resource的输出220V，将它转换成5V的电压并输出。
    对象适配器：与类适配器的区别在于，适配器Adaptor只实现Target，然后持有Resource对象（成员属性）。

桥接模式：又称为接口模式。用来变相的实现多继承。对于两个维度的东西进行关联，不使用继承实现，抽象类和接口实现类分离。
    例子：手机有很多的品牌（比如小米、华为）等，有很多颜色（红色、黑色）等。用户需要得到一个手机和颜色的组合。
    实现：先创建一个颜色接口Color，写一个方法getColor（）设置颜色，
        写两个实例实现Color，Red和Black，重写getColor方法。
        创建一个手机抽象类，持有颜色对象，并创建一个抽象方法setBrand（），
        创建类继承抽象类，该类调用抽象类的持有对象color的方法设置手机颜色，获得每个品牌的对应的颜色手机。

装饰者模式：对于当前对象（主体）进行一层一层的封装称为装饰者模式。
    例子：如去咖啡馆点咖啡，需要点咖啡种类（多种）和调料类型（多种），调料类型可以添加多份。
    实现：新建一个抽象类Drink，把咖啡和调料的共有属性（比如name名称、price单价等）抽出来,并写上get/set方法，以及需要一个得到总价的方法cost（）。
        新建一个类Coffee继承抽象类Drink，Coffee作为主要的饮品，可以单点，设置单点一份咖啡的花费cost（）方法为Super.getPrice()方法。
        然后新建每一种咖啡继承Coffee，并设置每一种对应的名称和单价。每一种咖啡是主体。
        新建一个包装类（Decorator），继承Drink，并持有Drink对象obj（Coffee），（持有Drink对象是为了获取Coffee的价格便于计算总价）。
        新建多种调料继承Decorator，并设置每一种对应的名称和单价，每一种调料是一次包装。加一次的调料花费总价为Coffee加上调料的price，即Cost（）为obj.getPrice()+super.getprice()

组合模式：又称为部分整体模式
    例子：类似于大学包含多个学院，学院包含多个系，系包含多个班级
         创建一个抽象类（接口），该抽象类包含大学，学院，系，班级的公共属性，以及通用方法。
         大学，学院，系，班级继承自该抽象类
         大学继承自抽象类，并创建一个泛型数组（抽象类的实现（学院）），重写抽象类的方法
         学院继承自抽象类，并创建一个泛型数组（抽象类的实现（系）），重写抽象类的方法
         班级继承自抽象类，重写抽象类的方法

外观模式：将一系列的复杂操作进行封装，并提供一个相对简单的方法给外部调用，隐藏具体的复杂实现逻辑。

享元模式：运用共享技术支持大量的细粒度的对象。主要运用于池技术（String常量池，数据库连接池、缓冲池等）。享是共享、元是对象。
    例子：先定义一个抽象享元类FlyWeight，包含内部状态和外部状态（内部状态指对象共享出来的信息，存储在享元对象内部并且不会随环境的改变而改变；外部状态指对象得以依赖的一个标记，是随环境改变而改变的、不可共享的状态。）
        ConcreteFlyweight是具体享元角色，是具体的产品类，实现抽象角色定义的业务；
        FlyweightFactory是享元工厂，它用于构造一个池容器，同时提供从池中获得对象的方法。

代理模式：为一个对象提供一个替身，已控制对这个对象的访问，即通过代理对象范文目标对象。
    这样做的好处是：可以在目标对象实现的将基础上，增强额外的功能操作，即扩展目标对象的功能。
    被代理的对象可以是：远程对象，创建开销大的对象，或需要安全控制的对象。
    代理有三种不同的形式：静态代理、动态代理（jdk代理，接口代理）、cglib代理（可以在内存动态的创建对象，而不需要实现接口，也属于动态代理的范畴）

    按照代理的创建时期，代理类可以分为两种：
        静态：由程序员创建代理类或特定工具自动生成源代码再对其编译。在程序运行前代理类的.class文件就已经存在了；
        动态：在程序运行时运用反射机制动态创建而成。

    静态代理的缺点：
        代理对象和被代理对象需要实先相同的接口，相同的方法，当被代理对象很多时，会产生很多的代理类，
        接口变更时，被代理对象和代理对象都需要变更，系统维护比较复杂。

    动态代理和静态代理需要实现接口，cglib代理不需要实现接口。
    cglib代理通过实现MethodInterception接口，实现步骤为：
        // 1、维护一个目标对象target
        // 2、构造器，传入被代理的对象
        // 3、返回一个代理对象: 是target对象的代理对象
            // 创建一个工具类
            Enhancer enhancer = new Enhancer();
            // 设置父类
            enhancer.setSuperclass(target.getClass());
            // 设置回调函数
            enhancer.setCallback(this);
            // 创建子类，即代理对象
            return enhancer.create();
        // 4、重写intercept方法，会调用目标对象的方法
            Object result = method.invoke(target, objects);


 
